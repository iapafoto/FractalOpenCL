{"slider":{"sliderMins":["-1.0371","-0.7862","-0.1255","0.5"],"sliderMaxs":["0.6739","1.0218","1.2215","0.9"],"sliders":["0.8435","5.0","0.8182","10.0"]},"code":"#define TEXTURE_IN_FLOAT\n\/\/#define TEXTURE_OUT_FLOAT\n\n#define DE_RAY pseudoKleinianSlider\n#define DE_COLOR pseudoKleinianSliderColor\n\n\/\/ #define DE kleinian\n\/\/ #define DE deSpace\n\/\/ #define DE apollonian\n\n\/\/#define WITH_SHADOWS\n\/\/#define WITH_SUN\n\/\/#define WITH_AO\n\/\/#define ONLY_AO\n\/\/#define WITH_VIGNETING\n\/\/#define WITH_DEPTH_OF_FIELD\n\/\/#define WITH_ISOLINE\n\n#ifdef ONLY_AO\n    #define BACK_COLOR (float3)(.8f, .8f, .8f) \n#else \n    #define BACK_COLOR (float3)(.08f, .16f, .34f) \n\/\/    #define BACK_COLOR (float3)(.8f, .65f, .54f) \n#endif\n\n#define FOCUSBLUR .005f\n\n#define PRECISION_FACTOR 3e-4\n#define MIN_DIST_RAYMARCHING .01f\n#define MAX_DIST_RAYMARCHING 15.f\n\n#define MIN_DIST_SHADOW 10.f*PRECISION_FACTOR\n#define MAX_DIST_SHADOW 3.f\n#define PRECISION_FACTOR_SHADOW PRECISION_FACTOR\n\n#define MIN_DIST_AO 10.f*PRECISION_FACTOR\n#define MAX_DIST_AO .2f\n#define PRECISION_FACTOR_AO PRECISION_FACTOR\n\n#define LIGHT_VEC normalize((float3)(.2,.7, 1.6) )\n\n#define DIFF 0\n#define REFR 1\n#define SPEC 2\n#define CHECK 3\n\n#define PATH_TRACING_DEPTH 5\n#define EYEPATHLENGTH 4\n\n\ntypedef struct Material {\n\tfloat3 emission; \n\tfloat3 colour; \n\tint type;\n} Material;\n\n\nconst sampler_t sampler_linear = CLK_NORMALIZED_COORDS_FALSE |  CLK_ADDRESS_CLAMP_TO_EDGE | CLK_FILTER_LINEAR;\n\n__constant float3 COLOR_WATER = (float3)(0.3f, 0.13f, 0.08f);\n__constant float3 COLOR_BACK = (float3)(.42f,.46f,.48f);    \n\n__constant int iter = 100;\n__constant float eps = 0.001f, far = 3.f;\n\n\ntypedef struct matrix3 {\n\tfloat3 m[3];\n}\nmatrix3;\n\n\ntypedef struct Context {\n    const float4 mins;\n    const float4 maxs;\n    const matrix3 rot;\n} Context;\n\n\ninline float3 reflect(const float3 i, const float3 n){\n  return i - 2.f * n * dot(n,i);\n}\n\ninline float3 refract(float3 v, float3 normal, float n){\n\t\/\/ assumes that n is already normalized\n\tfloat ct1 = dot(normal, -1 * v);\n\tfloat ct2 = sqrt(1 - n*n*(1 - ct1*ct1));\n\treturn n * v + (n * ct1 - ct2) * normal;\n}\n\nfloat3 nSphere( float3 pos, float4 sph ) {\n    return (pos-sph.xyz)\/sph.w;\n}\n\n\/\/ -------------------------------------------------------------------\n\ninline float hash1(float* seed) {\n    float fractptr;\n    return fract(sin((*seed+=.1f))*43758.5453123f, &fractptr);\n}\ninline float2 hash2(float* seed) {\n    float2 fractptr;\n    return fract(sin((float2)((*seed+=.1)*43758.5453123f,(*seed+=.1)*22578.1459123f)), &fractptr);\n}\n\ninline float3 hash3(const float seed) {\n    float3 fractptr;\n    return fract(sin((float3)(seed,seed+.1f,seed+.2f))*(float3)(43758.5453123f,22578.1459123f,19642.3490423f), &fractptr);\n}\n\nfloat rand(float2 co){\n\tfloat fractptr;\n\treturn fract(sin(dot(co.xy ,(float2)(12.9898f,78.233f))) * 43758.5453f, &fractptr);\n}\n\nmatrix3  rotationMatrix3(const float3 v, const float angle) {\n\tconst float c = cos(angle), s = sin(angle);\n\tmatrix3 m;\n\tm.m[0] = (float3)(c + (1.f - c) * v.x * v.x, (1.f - c) * v.x * v.y - s * v.z, (1.f - c) * v.x * v.z + s * v.y);\n\tm.m[1] = (float3)((1.f - c) * v.x * v.y + s * v.z, c + (1.f - c) * v.y * v.y, (1.f - c) * v.y * v.z - s * v.x);\n\tm.m[2] = (float3)((1.f - c) * v.x * v.z - s * v.y, (1.f - c) * v.y * v.z + s * v.x, c + (1.f - c) * v.z * v.z);\n\treturn m;\n}\n\n\n\n\nfloat3 cosWeightedRandomHemisphereDirection( const float3 n, float* seed ) {\n  \tfloat2 r = hash2(seed);\n    \n\tfloat3  uu = normalize( cross( n, (float3)(0.f,1.f,1.f) ) );\n\tfloat3  vv = cross( uu, n );\n\t\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(6.2831f*r.x); \n\tfloat ry = ra*sin(6.2831f*r.x);\n\tfloat rz = sqrt( 1.f-r.y );\n\tfloat3  rr = (float3)( rx*uu + ry*vv + rz*n );\n    \n    return normalize( rr );\n}\n\nfloat3 randomSphereDirection(float* seed) {\n    float2 r = hash2(seed)*6.2831f;\n\tfloat3 dr = (float3)(sin(r.x)*(float2)(sin(r.y),cos(r.y)),cos(r.x));\n\treturn dr;\n}\n\nfloat3 randomHemisphereDirection( const float3 n, float* seed ) {\n\tfloat3 dr = randomSphereDirection(seed);\n\treturn dot(dr,n) * dr;\n}\n\n\/\/-----------------------------------------------------\n\/\/ light\n\/\/-----------------------------------------------------\n\/*\nfloat4 lightSphere;\n\nvoid initLightSphere( float time ) {\n\tlightSphere = (float4)( 3.f+2.f*sin(time),2.8f+2.f*sin(time*0.9f),3.f+4.f*cos(time*.7f), .5f );\n}\n*\/\n\nfloat3 sampleLight(float3 ro, float* seed, float4 lightSphere) {\n    float3 n = randomSphereDirection( seed ) * lightSphere.w;\n    return lightSphere.xyz + n;\n}\n\nint box(const float3 ro, const float3 rd, const float3 sz, float* tN, float* tF, float3* n) {\n    const float3 m = 1.f\/rd,  k = fabs(m)*sz,  a = -m*ro-k*.5f, b = a+k;\n    *n = -sign(rd) * step(a.yzx,a.xyz) * step(a.zxy,a.xyz);\n    *tN = max(max(a.x,a.y),a.z);\n    *tF = min(min(b.x,b.y),b.z);\n    return *tN<*tF && *tF>0.f ? 1.f : 0.f;\n}\n\ninline float map(const float a0, const float b0, const float a1, const float b1, const float v) {\n    return mix(a1,b1,(v-a0)\/(b0-a0));\n}\n\n\/\/ -----------------------------------------------------\n\nfloat cylUnion(const float3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.f;\n}\n\nfloat cylIntersection(const float3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.f;\n}\n\n\n#define R(p, a) p=cos(a)*p+sin(a)*(float2)(p.y, -p.x)\n\n\nfloat pseudoKleinianSlider(float3 p, const Context* ctx) {\/\/knighty's pseudo kleinian\n    float k,r2, scale=1.f, orb = 1.f;\n    for(int i=0;i<7;i++) {\n       \/\/ if(i==rotater)p.xy=p.xy*rmx;\n        p = 2.f*clamp(p, ctx->mins.xyz, ctx->maxs.xyz)-p;\n        r2 = dot(p,p);\n        k = max(ctx->mins.w\/dot(p,p),1.f);\n        p *= k;\n        scale *= k;\n    }\n    float rxy=length(p.xy);\n    return .5f*max(rxy-ctx->maxs.w, \/*fabs*\/(rxy*p.z) \/ length(p))\/scale;\n}\n\nfloat pseudoKleinianSliderSymetrique(float3 p, const Context* ctx) {\/\/knighty's pseudo kleinian\n    float k, scale = 1.f;\n    for(int i=0;i<8;i++) {\n        p = 2.f*clamp(p, ctx->mins.xyz, ctx->maxs.xyz)-p;\n        k = max(ctx->mins.w \/ dot(p,p),1.f);\n        p *= k;\n        scale *= k;\n    }\n    return .5f*max(1.f-ctx->maxs.w\/length(p), \/*fabs*\/(max(p.x, max(p.y, p.z))))\/scale;\n}\n\nfloat3 pseudoKleinianSliderColor(float3 p, const Context* ctx) {\/\/knighty's pseudo kleinian\n    float k,r2, scale = 1.f, orb = 1.f;\n    for(int i=0;i<8;i++) {\n        p = 2.f*clamp(p, ctx->mins.xyz, ctx->maxs.xyz)-p;\n        r2 = dot(p,p);\n        orb = min(orb, r2);\n        k = max(ctx->mins.w\/r2,1.f);\n        p *= k;\n        scale *= k;\n    }\n    return (float3)(0.f, .25f+sqrt(orb), orb);\n}\n\n\n\ninline float rayIntersect(const float3 ro, const float3 rd, const Context* ctx, const float precision, const float mind, const float maxd) {\n    float h, t = mind;\n    for(int i=0; i<192; i++ ) {\n        h = DE_RAY(ro+rd*t, ctx);\n        if (h<precision*t || t>maxd) \n            return t;\n        t += h;\n    }\n    return -1.f;\n}\n\nfloat3 trace(const float3 ro, const float3 rd, const Context* ctx ) {\n    const float d = rayIntersect(ro, rd, ctx, PRECISION_FACTOR, MIN_DIST_RAYMARCHING, MAX_DIST_RAYMARCHING);\n    if (d>0.f) {\n        return (float3)(d, DE_COLOR(ro+rd*d, ctx).yz);\n    }\n    return (float3)(-1.f, 1.f, 0.f);\n}\n\nfloat3 calcNormal( float3 pos, float t,const Context* ctx ){\n    const float precis = PRECISION_FACTOR * t * 0.57f;\n    const float3 e = (float3)(precis, -precis, 0.f);\n\n    return normalize(e.xyy*DE_RAY(pos + e.xyy, ctx) + \n\t\t     e.yyx*DE_RAY(pos + e.yyx, ctx) + \n\t\t     e.yxy*DE_RAY(pos + e.yxy, ctx) + \n                     e.xxx*DE_RAY(pos + e.xxx, ctx) );\n}\n\n\/*\nfloat3 calcNormal(const float3 p, const float t, const Context* ctx){\n    const float eps = PRECISION_FACTOR * t * 0.57f;\n    float3 e = (float3)(eps, 0.f, 0.f);\n    return normalize((float3)(\n\t\tDE_RAY(p+e.xyy,ctx)-DE_RAY(p-e.xyy,ctx),\n\t\tDE_RAY(p+e.yxy,ctx)-DE_RAY(p-e.yxy,ctx),\n\t\tDE_RAY(p+e.yyx,ctx)-DE_RAY(p-e.yyx,ctx)));\n}\n*\/\n\nfloat iSphere( float3 ro, float3 rd, float4 sph ) {\n    float3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.f) return -1.f;\n\n\tfloat s = sqrt(h);\n\tfloat t1 = -b - s;\n\tfloat t2 = -b + s;\n\t\n\treturn t1 < 0.f ? t2 : t1;\n}\n\n\nfloat2 intersect( float3 ro, float3 rd, const Context* ctx,  float3* normal, float4 lightSphere) {\n\tfloat2 res = (float2)( 1e20, -1.f );\n\n\tfloat3 intersectFractal = trace(ro,rd, ctx);\n\tres.x = intersectFractal.x;\n\tres.y = 1.f;\n\tfloat t;\n\t\n   \/\/ t = iSphere( ro, rd, (float4)( 1.5,1.0, 2.7, 1.0) ); if( t>eps && t<res.x ) { res = (float2)( t, 1. ); normal = nSphere( ro+t*rd, (float4)( 1.5,1.0, 2.7,1.0) ); }\n   \/\/ t = iSphere( ro, rd, (float4)( 4.0,1.0, 4.0, 1.0) ); if( t>eps && t<res.x ) { res = (float2)( t, 6. ); normal = nSphere( ro+t*rd, (float4)( 4.0,1.0, 4.0,1.0) ); }\n    t = iSphere( ro, rd, lightSphere ); \n\tif( t>eps && t<res.x ) { \n\t\tres = (float2)( t, 0.0 );  \n\t\t*normal = nSphere( ro+t*rd, lightSphere ); }\n\telse \n{\n \t\t*normal = calcNormal(ro+rd*intersectFractal.x, intersectFractal.x, ctx);\n\t}\n\t\t\t\t\t  \n    return res;\t\t\t\t\t  \n}\n\nbool intersectShadow( float3 ro, float3 rd, float dist, const Context* ctx) {\n    float t = rayIntersect(ro, rd, ctx, PRECISION_FACTOR, MIN_DIST_RAYMARCHING, dist\/*MAX_DIST_RAYMARCHING*\/);\n    return (t>0.f && t<=dist \/*MAX_DIST_RAYMARCHING*\/);\n}\n\n\n\n\/\/-----------------------------------------------------\n\/\/ materials\n\/\/-----------------------------------------------------\n\n#define LIGHTCOLOR (float3)(16.86, 10.76, 8.2)*1.3\n#define WHITECOLOR (float3)(.7295, .7355, .729)*0.7\n#define GREENCOLOR (float3)(.117, .4125, .115)*0.7\n#define REDCOLOR (float3)(.611, .0555, .062)*0.7\n\nfloat3 matColor( float mat ) {\n    float3 nor = (float3)(0.f, 0.95f, 0.f);\n    if ( mat<3.5f ) nor = REDCOLOR;\n    if ( mat<2.5f ) nor = GREENCOLOR;\n    if ( mat<1.5f ) nor = WHITECOLOR;\n    if ( mat<0.5f ) nor = LIGHTCOLOR;\t\t\t\t  \n    return nor;\t\t\t\t\t  \n}\n\nbool matIsSpecular( float mat ) {\n    return mat > 4.5;\n}\n\nbool matIsLight( float mat ) {\n    return mat < 0.5;\n}\n\n\/\/-----------------------------------------------------\n\/\/ brdf\n\/\/-----------------------------------------------------\n\nfloat3 getBRDFRay( float3 n, float3 rd,float m, bool* specularBounce, float* seed ) {\n    *specularBounce = false;\n    \n    float3 r = cosWeightedRandomHemisphereDirection( n, seed );\n    if(  !matIsSpecular( m ) ) {\n        return r;\n    } else {\n        *specularBounce = true;\n        \n        float n1, n2, ndotr = dot(rd,n);\n        \n        if( ndotr > 0. ) {\n            n1 = 1.\/1.5; n2 = 1.;\n            n = -n;\n        } else {\n            n2 = 1.\/1.5; n1 = 1.;\n        }\n                \n        float r0 = (n1-n2)\/(n1+n2); r0 *= r0;\n\t\tfloat fresnel = r0 + (1.-r0) * pow(1.0-fabs(ndotr),5.);\n        \n        float3 ref;\n        \n        if( hash1(seed) < fresnel ) {\n            ref = reflect( rd, n );\n        } else {\n            ref = refract( rd, n, n2\/n1 );\n        }\n        \n        return ref; \/\/ normalize( ref + 0.1 * r );\n\t}\n}\n\n\/\/-----------------------------------------------------\n\/\/ eyepath\n\/\/-----------------------------------------------------\n\nfloat3 traceEyePath( float3 ro, float3 rd, Context* ctx, bool directLightSampling, float* seed ) {\n    float3 tcol = (float3)(0.);\n    float3 fcol  = (float3)(1.);\n    \n    bool specularBounce = true;\n    float time = 1.f;\n    float4 lightSphere = (float4)( 3.f+2.f*sin(time),2.8f+2.f*sin(time*0.9f),3.f+4.f*cos(time*.7f), .5f );\n   float3 normal;\n\n    for( int j=0; j<EYEPATHLENGTH; ++j ) {\n     \n     \n        float2 res = intersect( ro, rd, ctx, &normal, lightSphere );\n        if( res.y < -0.5 ) {\n            return tcol;\n        }\n        \/*\n        if( matIsLight( res.y ) ) {\n            if( directLightSampling ) {\n            \tif( specularBounce ) tcol += fcol*LIGHTCOLOR;\n            } else {\n                tcol += fcol*LIGHTCOLOR;\n            }\n         \/\/   basecol = vec3(0.);\t\/\/ the light has no diffuse component, therefore we can return col\n            return tcol;\n        }\n        \n        ro = ro + res.x * rd;\n        rd = getBRDFRay( normal, rd, res.y, specularBounce, seed );\n        \n        fcol *= matColor( res.y );\n\n        float3 ld = sampleLight( ro, &seed, lightSphere) - ro;\n        \n        if( directLightSampling ) {\n\t\t\tfloat3 nld = normalize(ld);\n            if( !specularBounce && j < EYEPATHLENGTH-1 && !intersectShadow( ro, nld, length(ld), ctx) ) {\n\n                float cos_a_max = sqrt(1. - clamp(lightSphere.w * lightSphere.w \/ dot(lightSphere.xyz-ro, lightSphere.xyz-ro), 0., 1.));\n                float weight = 2. * (1. - cos_a_max);\n\n                tcol += (fcol * LIGHTCOLOR) * (weight * clamp(dot( nld, normal ), 0., 1.));\n            }\n        }\n*\/\n    }   \n \n    return tcol;\n}\n\nfloat3 getRay(float3 ro, float3 look, float2 uv){\n    float3 f = normalize(look - ro);\n    float3 r = normalize((float3)(f.z,0.f,-f.x));\n    float3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\n\n\n\/\/ Cameras \n#ifndef WITH_DEPTH_OF_FIELD\n\nfloat3 RD(const float3 ro, const float3 ww,  const float3 uu, const float x, const float y, const int2 res, const float fov) {\n    const float3 \n\/\/        ww = normalize(ta - ro),\n\/\/        uu = normalize(cross(ww, (float3)(0.f,0.f,1.f))), \/\/ up\n        vv = normalize(cross(uu,ww));\n\n    const float2 resF = convert_float2(res);\n    const float px = (2.f * (x\/resF.x) - 1.f) * resF.x\/resF.y, \n                py = (2.f * (y\/resF.y) - 1.f);  \n\n    float3 er = normalize( (float3)( px, py, fov) );\n    return normalize( er.x*uu + er.y*vv + er.z*ww );\n    \/\/return normalize( px*uu + py*vv + fov*ww );\n}\n\n#else\n\n\nfloat3 RD_DOF(float3* ro, const float3 ww, const float3 uu, const float x, const float y, const int2 res, const float fov, const float focusDist, const float2 rv2) {\n    const float3\n   \/\/     ww = normalize(ta - *ro),\n   \/\/     uu = normalize(cross(ww, (float3)(0.f,0.f,1.f))), \/\/ up\n        vv = normalize(cross(uu,ww));\n   \n \/\/float2 rv2 = hash2(24.4316544311f*seed);  \n    float2 resF = convert_float2(res);\n    float2 q = ((float2)(x,y))\/resF;\n\n    float2 p = 2.f*q - 1.f;\n    p.x *= resF.x\/resF.y;\n\n    float2 pt = p + rv2\/resF;   \n \n\n    float3 er = normalize( (float3)( pt.xy, fov*2.f ) );\n    float3 rd = er.x*uu + er.y*vv + er.z*ww;\n\n    float3 go = FOCUSBLUR*(float3)(2.f*rv2-1.f, 0.f);\n    float3 gd = normalize( er*focusDist - go );\n\n    *ro += go.x*uu + go.y*vv;\n    rd += gd.x*uu + gd.y*vv;\n    rd = normalize(rd);\n    return rd;\n}\n\n#endif\n\n\n\n__kernel void render(float3 ro, float3 ww, float3 uu, const float4 sliderMins, const float4 sliderMaxs, \n    write_only image2d_t outputImage, const float4 deltaPix, read_only image2d_t demPalette,\n    global write_only float* zBuffer, const float4 camera) {\n    \n    const int x = get_global_id(0);\n    const int y = get_global_id(1);\n    const int2 outSize = get_image_dim(outputImage);\n    \n\n\n    if (x>=outSize.x || y>=outSize.y) return;\n    \n    const float3 RotVector = sliderMins.xyz;\/\/(float3)(0.5f,-0.05f,-0.5f);\n    matrix3 matRot = rotationMatrix3(normalize(RotVector), 99.f);\n\n\tContext ctx = {sliderMins, sliderMaxs, matRot};\n    \/\/ create ray with depth of field\n    const float fov = camera.x; \/\/ 3.f;\n       \t\n   \/\/ ro.y -= 40.f;\t\n  \/\/  ta.y -= 3.f;\n\n    float2 res = convert_float2(outSize);\n    const float2 q = ((float2)(x,y)+deltaPix.xy)\/res;\n\n#ifdef WITH_DEPTH_OF_FIELD\n    float FOCUSDISTANCE = camera.y; \/\/.05f;\/\/length(ro-ta)*.75f;\n    const float3 rd = RD_DOF(&ro, ww, uu, (float)(x)+deltaPix.x, (float)(y)+deltaPix.y, outSize, fov, FOCUSDISTANCE, deltaPix.zw); \n#else\n    const float3 rd = RD(ro, ww, uu, (float)(x)+deltaPix.x, (float)(y)+deltaPix.y, outSize, fov);\n#endif\t\n\n    const float3 cback = (float3)(.1*(1.-length(q-.5)));\n    float dist = 0.f;\n\tfloat seed = deltaPix.x+deltaPix.y; \/\/\n\tfloat3 col = traceEyePath( ro, rd, &ctx, true, &seed );\n  \/\/  float3 col = renderScene(ro, rd, &ctx, &dist);\n\n#ifdef WITH_VIGNETING\n    col *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .3); \/\/ vigneting\n#endif\n\n    float4 out = (float4)(clamp(col,(float3)(0.f), (float3)(1.f)),1.f);\n\n#ifdef TEXTURE_OUT_FLOAT\n    write_imagef(outputImage, (int2)(x, y), out); \n#else\n    uint4 rgba = (uint4)((int)(out.z*256.f),\n                         (int)(out.y*256.f),\n                         (int)(out.x*256.f), 256);\n    write_imageui(outputImage, (int2)(x, y), rgba); \n#endif\n    zBuffer[x+y*outSize.x] = dist;\n}\n\n\n\/\/__kernel void dummy(const float3 roo) {\n\/\/    \n\/\/}\n\n\n","camera":{"aperture":0.0,"focal":3.0,"pos":["-2.6787176800615637","-2.020702573677572","0.6152525813727303"],"focdist":1.050137996673584,"width":359,"up":["-0.18325017038845548","-0.13677726749894797","0.9735046759765067"],"look":["-0.27464459356713256","-0.943719871510213","-0.1842909421026756"],"height":267}}