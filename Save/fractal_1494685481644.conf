{"slider":{"sliderMins":["-2.5416","2.0","-0.2279","0.105"],"sliderMaxs":["2.1319","2.0","2.0","1.6364"],"sliders":["0.0576","1.8118","-4.5711","10.0"]},"code":"#define TEXTURE_IN_FLOAT\n\/\/#define TEXTURE_OUT_FLOAT\n\n#define DE_RAY kaliFractal\n\/\/pseudoKleinianSlider \n#define DE_COLOR kaliFractalColor\n\/\/pseudoKleinianSliderColor \n\n\/\/ #define DE kleinian\n\/\/ #define DE deSpace\n\/\/ #define DE apollonian\n\n\n#define NB_ITERATIONS 28\n\n\n#define WITH_SHADOWS\n\/\/#define WITH_SUN\n#define WITH_AO\n\/\/#define ONLY_AO\n\/\/#define WITH_VIGNETING\n\/\/#define WITH_DEPTH_OF_FIELD\n\/\/#define WITH_ISOLINE\n\n#ifdef ONLY_AO\n    #define BACK_COLOR (float3)(.8f, .8f, .8f) \n#else \n  \/\/  #define BACK_COLOR (float3)(.08f, .16f, .34f) \n    #define BACK_COLOR .2f*(float3)(.8f, .65f, .54f) \n#endif\n\n#define FOCUSBLUR .005f\n\n#define PRECISION_FACTOR 5e-4\n#define MIN_DIST_RAYMARCHING .01f\n#define MAX_DIST_RAYMARCHING 100.f\n\n#define MIN_DIST_SHADOW 10.f*PRECISION_FACTOR\n#define MAX_DIST_SHADOW 100.f\n#define PRECISION_FACTOR_SHADOW 1e-3\n\n#define MIN_DIST_AO 10.f*PRECISION_FACTOR\n#define MAX_DIST_AO .16f\n#define PRECISION_FACTOR_AO 1e-3\n\n#define LIGHT_VEC normalize((float3)(-.5,-.7, .6) )\n\n#define PALETTE_0(x) (.5f + 0.5f*cos(6.2831f*(x) + (float3)(0.f,1.f,2.f))); \n#define PALETTE_1(x) pal( x, (float3)(0.5f,0.5f,0.5f),(float3)(0.5f,0.5f,0.5f),(float3)(1.f,1.f,1.f),(float3)(0.f,0.33f,0.67f) );\n#define PALETTE_2(x) pal( x, (float3)(0.5f,0.5f,0.5f),(float3)(0.5f,0.5f,0.5f),(float3)(1.f,1.f,1.f),(float3)(0.f,0.10f,0.20f) );\n#define PALETTE_3(x) pal( x, (float3)(0.5f,0.5f,0.5f),(float3)(0.5f,0.5f,0.5f),(float3)(1.f,1.f,1.f),(float3)(0.3f,0.20f,0.20f) );\n#define PALETTE_4(x) pal( x, (float3)(0.5f,0.5f,0.5f),(float3)(0.5f,0.5f,0.5f),(float3)(1.f,1.f,0.5f),(float3)(0.8f,0.90f,0.30f) );\n#define PALETTE_5(x) pal( x, (float3)(0.5f,0.5f,0.5f),(float3)(0.5f,0.5f,0.5f),(float3)(1.f,0.7f,0.4f),(float3)(0.f,0.15f,0.20f) );\n#define PALETTE_6(x) pal( x, (float3)(0.5f,0.5f,0.5f),(float3)(0.5f,0.5f,0.5f),(float3)(2.f,1.f,0.f),(float3)(0.5f,0.20f,0.25f) );\n#define PALETTE_7(x) pal( x, (float3)(0.8f,0.5f,0.4f),(float3)(0.2f,0.4f,0.2f),(float3)(2.f,1.f,1.f),(float3)(0.f,0.25f,0.25f) );\n    \n#define PALETTE PALETTE_0\n\n\n\n#define DIFF 0\n#define REFR 1\n#define SPEC 2\n#define CHECK 3\n\n#define PATH_TRACING_DEPTH 8\n\ntypedef struct Material {\n\tfloat3 emission; \n\tfloat3 colour; \n\tint type;\n} Material;\n\n\n\nconst sampler_t sampler_linear = CLK_NORMALIZED_COORDS_FALSE |  CLK_ADDRESS_CLAMP_TO_EDGE | CLK_FILTER_LINEAR;\n\n__constant float3 COLOR_WATER = (float3)(0.3f, 0.13f, 0.08f);\n__constant float3 COLOR_BACK = (float3)(.42f,.46f,.48f);    \n\n__constant int iter = 100;\n__constant float eps = 0.001f, far = 3.f;\n\ntypedef struct matrix3 {\n\tfloat3 m[3];\n}\nmatrix3;\n\n\ntypedef struct Context {\n    const float4 mins;\n    const float4 maxs;\n    const matrix3 rot;\n} Context;\n\n\ninline float3 reflect(const float3 i, const float3 n){\n  return i - 2.f * n * dot(n,i);\n}\n\n\/\/ -------------------------------------------------------------------\n\nfloat rand(float2 co){\n\tfloat fractptr;\n\treturn fract(sin(dot(co.xy ,(float2)(12.9898f,78.233f))) * 43758.5453f, &fractptr);\n}\n\ninline float hash1(const float seed) {\n    float fractptr;\n    return fract(sin(seed)*43758.5453123f, &fractptr);\n}\ninline float2 hash2(const float seed) {\n    float2 fractptr;\n    return fract(sin((float2)(seed*43758.5453123f,(seed+.1)*22578.1459123f)), &fractptr);\n}\ninline float3 hash3(const float seed) {\n    float3 fractptr;\n    return fract(sin((float3)(seed,seed+.1f,seed+.2f))*(float3)(43758.5453123f,22578.1459123f,19642.3490423f), &fractptr);\n}\n\n\/\/ -------------------------------------------------------------------------\n\/\/   MATRIX 3x3\n\/\/ -------------------------------------------------------------------------\n\n\nfloat3 mvmul3(const matrix3 m, const float3 v) {\n\treturn (float3)(dot(m.m[0],v),dot(m.m[1],v),dot(m.m[2],v));\n}\n\nfloat det3(const matrix3 m) {\n\treturn\n\t  m.m[0].x*m.m[1].y*m.m[2].z - m.m[0].x*m.m[1].z*m.m[2].y +\n\t  m.m[0].y*m.m[1].z*m.m[2].x - m.m[0].y*m.m[1].x*m.m[2].z +\n\t  m.m[0].z*m.m[1].x*m.m[2].y - m.m[0].z*m.m[1].y*m.m[2].x;\n}\n\nmatrix3 invert3(const matrix3 m) {\n\tmatrix3 im;\n\tfloat det = det3(m);\n\tim.m[0].x = +(m.m[1].y*m.m[2].z - m.m[1].z*m.m[2].y)\/det;\n\tim.m[1].x = -(m.m[1].x*m.m[2].z - m.m[1].z*m.m[2].x)\/det;\n\tim.m[2].x = +(m.m[1].x*m.m[2].y - m.m[1].y*m.m[2].x)\/det;\n\tim.m[0].y = -(m.m[0].y*m.m[2].z - m.m[0].z*m.m[2].y)\/det;\n\tim.m[1].y = +(m.m[0].x*m.m[2].z - m.m[0].z*m.m[2].x)\/det;\n\tim.m[2].y = -(m.m[0].x*m.m[2].y - m.m[0].y*m.m[2].x)\/det;\n\tim.m[0].z = +(m.m[0].y*m.m[1].z - m.m[0].z*m.m[1].y)\/det;\n\tim.m[1].z = -(m.m[0].x*m.m[1].z - m.m[0].z*m.m[1].x)\/det;\n\tim.m[2].z = +(m.m[0].x*m.m[1].y - m.m[0].y*m.m[1].x)\/det;\n\treturn im;\n}\n\nmatrix3 transpose3(const matrix3 m) {\n\tmatrix3 tm;\n\ttm.m[0] = (float3)(m.m[0].x,m.m[1].x,m.m[2].x);\n\ttm.m[1] = (float3)(m.m[0].y,m.m[1].y,m.m[2].y);\n\ttm.m[2] = (float3)(m.m[0].z,m.m[1].z,m.m[2].z);\n\treturn tm;\n}\n\nmatrix3  rotationMatrix3(const float3 v, const float angle) {\n\tconst float c = cos(angle), s = sin(angle);\n\tmatrix3 m;\n\tm.m[0] = (float3)(c + (1.f - c) * v.x * v.x, (1.f - c) * v.x * v.y - s * v.z, (1.f - c) * v.x * v.z + s * v.y);\n\tm.m[1] = (float3)((1.f - c) * v.x * v.y + s * v.z, c + (1.f - c) * v.y * v.y, (1.f - c) * v.y * v.z - s * v.x);\n\tm.m[2] = (float3)((1.f - c) * v.x * v.z - s * v.y, (1.f - c) * v.y * v.z + s * v.x, c + (1.f - c) * v.z * v.z);\n\treturn m;\n}\n\n\nmatrix3  rotationMatrix3bis(const float3 v, const float angle) {\n\tconst float c = cos(angle), s = sin(angle);\n\tmatrix3 m;\n\tm.m[0] = (float3)(c + (1.f - c) * v.x * v.x,   (1.f - c) * v.x * v.y + s * v.z,   (1.f - c) * v.x * v.z - s * v.y);\n\tm.m[1] = (float3)((1.f - c) * v.x * v.y - s * v.z, c + (1.f - c) * v.y * v.y, (1.f - c) * v.y * v.z + s * v.x);\n\tm.m[2] = (float3)((1.f - c) * v.x * v.z + s * v.y, (1.f - c) * v.y * v.z - s * v.x, c + (1.f - c) * v.z * v.z);\n\treturn m;\n}\n\n\n\/\/ -------------------------------------------------------------------------\n\n\ninline float3 randomCosWeightedHemiSphereVector(const float3 n, const float seed) {\n    const float r1 = 2.f*M_PI_F*hash1(seed), r2 = hash1(seed+.1f);\n    const float3 u = normalize(cross(n, (float3)(0.f,1.f,1.f))), v = cross(u,n);\n    return normalize(sqrt(r2)*(cos(r1)*u + sin(r1)*v) + sqrt(1.f-r2)*n);\n}\n\ninline float3 randomSphereDirection(const float seed) {\n    float2 r = 2.f*M_PI_F*hash2(seed);\n    return (float3)(sin(r.x)*(float2)(sin(r.y),cos(r.y)),cos(r.x));\n}\n\ninline float3 randomHemisphereDirection(const float3 n, const float seed) {\n    float2 r = 2.f*M_PI_F*hash2(seed);\n    float3 dr =  (float3)(sin(r.x)*(float2)(sin(r.y),cos(r.y)),cos(r.x));\n    float k = dot(dr,n);\n    return k == 0.f ? n : normalize(k*dr);\n}\n\n\nint box(const float3 ro, const float3 rd, const float3 sz, float* tN, float* tF, float3* n) {\n    const float3 m = 1.f\/rd,  k = fabs(m)*sz,  a = -m*ro-k*.5f, b = a+k;\n    *n = -sign(rd) * step(a.yzx,a.xyz) * step(a.zxy,a.xyz);\n    *tN = max(max(a.x,a.y),a.z);\n    *tF = min(min(b.x,b.y),b.z);\n    return *tN<*tF && *tF>0.f ? 1.f : 0.f;\n}\n\ninline float map(const float a0, const float b0, const float a1, const float b1, const float v) {\n    return mix(a1,b1,(v-a0)\/(b0-a0));\n}\n\n\/\/ -----------------------------------------------------\n\n\n\n#define R(p, a) p=cos(a)*p+sin(a)*(float2)(p.y, -p.x)\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat kaliFractal(float3 p, const Context* ctx) {\n\n    const float Scale = 1.27f; \/\/ctx->mins.w;\n    const float3 Julia = (float3)(-ctx->mins.w,-1.95,-ctx->maxs.w);\/\/ctx->mins.xyz;\n    for (int i=0; i<NB_ITERATIONS; i++) {\n        p.xy = fabs(p.xy);\n        p = p*Scale + Julia;\n        p = mvmul3(ctx->rot, p);\n    }\n    return length(p)*pow(Scale, -(float)(NB_ITERATIONS));\n}\n\nfloat3 kaliFractalColor(float3 p, const Context* ctx) {\n        float3 orbitTrap = (float3)(1000.f,1000.f,1000.f);\n\tfloat Scale = 1.27f;\n        float3 Julia = (float3)(-1.2,-1.95,-.6); \/\/ctx->mins.xyz;\n\n\tfor (int i=0; i<NB_ITERATIONS; i++) {\n            p.xy = fabs(p.xy);\n            p = p*Scale + Julia;\n            p = mvmul3(ctx->rot, p);\n\n        \/\/ EDIT: Update Orbittrap in Every Iteration,\n                \/\/here simple orbittrap of \"min\" is implemented, spherical orbittrap around sphere located at zero\n\t\t\/\/orbitTrap = min(orbitTrap,fabs(p));\n    \n             \/\/ EDIT: add an offset, spherical orbittrap around point \n\t\torbitTrap = min(orbitTrap, fabs(p+((float3)(1.f,1.f,1.f))));\n        \n            \/\/M Playing around, sinus of orbittrap makes interesting results ;)\n            \/\/orbitTrap = min(orbitTrap, fabs(sin(p)+1.f));\n\t}\n\treturn orbitTrap;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n\ninline float rayIntersect(const float3 ro, const float3 rd, const Context* ctx, const float precision, const float mind, const float maxd) {\n    float h, t = mind;\n    for(int i=0; i<192; i++ ) {\n        h = DE_RAY(ro+rd*t, ctx);\n        if (h<precision*t || t>maxd) \n            return t;\n        t += h;\n    }\n    return -1.f;\n}\n\nfloat3 trace(const float3 ro, const float3 rd, const Context* ctx ) {\n    const float d = rayIntersect(ro, rd, ctx, PRECISION_FACTOR, MIN_DIST_RAYMARCHING, MAX_DIST_RAYMARCHING);\n    if (d>0.f) {\n        return (float3)(d, DE_COLOR(ro+rd*d, ctx).yz);\n    }\n    return (float3)(-1.f, 1.f, 0.f);\n}\n\n\n\n\nfloat3 getRay(float3 ro, float3 look, float2 uv){\n    float3 f = normalize(look - ro);\n    float3 r = normalize((float3)(f.z,0.f,-f.x));\n    float3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\n\/*\nfloat3 calcNormal( float3 pos, float t,const Context* ctx ){\n    const float precis = PRECISION_FACTOR * t * 0.57f;\n    const float3 e = (float3)(precis, -precis, 0.f);\n\n    return normalize(e.xyy*DE_RAY(pos + e.xyy, ctx) + \n\t\t     e.yyx*DE_RAY(pos + e.yyx, ctx) + \n\t\t     e.yxy*DE_RAY(pos + e.yxy, ctx) + \n                     e.xxx*DE_RAY(pos + e.xxx, ctx) );\n}\n*\/\n\nfloat3 calcNormal(const float3 p, const float t, const Context* ctx){\n    const float eps = PRECISION_FACTOR * t * 0.57f;\n    float3 e = (float3)(eps, 0.f, 0.f);\n    return normalize((float3)(\n\t\tDE_RAY(p+e.xyy,ctx)-DE_RAY(p-e.xyy,ctx),\n\t\tDE_RAY(p+e.yxy,ctx)-DE_RAY(p-e.yxy,ctx),\n\t\tDE_RAY(p+e.yyx,ctx)-DE_RAY(p-e.yyx,ctx)));\n}\n\n\n\/*\nfloat3 light(float3 p, float3 n){\n\n    float3 col = (float3)(0);\n    float3 l1 = normalize((float3)(1,2,1));\n    float3 l2 = normalize((float3)(-1,1,-2));\n\n    float diff = max(dot(n,l1),0.);\n    diff *= getShadow(p, n, l1);\n    col += diff * (float3)(1,.8,.5);\n    diff = max(dot(n,l2),0.);\n    diff *= getShadow(p, n, l2);\n    col += diff * (float3)(.6,.8,1);\n\n    return col * .5;\n}\n*\/\n\n\n\/\/ Cameras \n#ifndef WITH_DEPTH_OF_FIELD\n\nfloat3 RD(const float3 ro, const float3 ww,  const float3 uu, const float x, const float y, const int2 res, const float fov) {\n    const float3 \n\/\/        ww = normalize(ta - ro),\n\/\/        uu = normalize(cross(ww, (float3)(0.f,0.f,1.f))), \/\/ up\n        vv = normalize(cross(uu,ww));\n\n    const float2 resF = convert_float2(res);\n    const float px = (2.f * (x\/resF.x) - 1.f) * resF.x\/resF.y, \n                py = (2.f * (y\/resF.y) - 1.f);  \n\n    float3 er = normalize( (float3)( px, py, fov) );\n    return normalize( er.x*uu + er.y*vv + er.z*ww );\n    \/\/return normalize( px*uu + py*vv + fov*ww );\n}\n\n#else\n\n\nfloat3 RD_DOF(float3* ro, const float3 ww, const float3 uu, const float x, const float y, const int2 res, const float fov, const float focusDist, const float2 rv2) {\n    const float3\n   \/\/     ww = normalize(ta - *ro),\n   \/\/     uu = normalize(cross(ww, (float3)(0.f,0.f,1.f))), \/\/ up\n        vv = normalize(cross(uu,ww));\n   \n \/\/float2 rv2 = hash2(24.4316544311f*seed);  \n    float2 resF = convert_float2(res);\n    float2 q = ((float2)(x,y))\/resF;\n\n    float2 p = 2.f*q - 1.f;\n    p.x *= resF.x\/resF.y;\n\n    float2 pt = p + rv2\/resF;   \n \n\n    float3 er = normalize( (float3)( pt.xy, fov*2.f ) );\n    float3 rd = er.x*uu + er.y*vv + er.z*ww;\n\n    float3 go = FOCUSBLUR*(float3)(2.f*rv2-1.f, 0.f);\n    float3 gd = normalize( er*focusDist - go );\n\n    *ro += go.x*uu + go.y*vv;\n    rd += gd.x*uu + gd.y*vv;\n    rd = normalize(rd);\n    return rd;\n}\n\n#endif\n\n\n\nfloat3 renderScene( float3 ro, float3 rd, const Context* ctx, float* dist) {\n\n\t\tfloat2 r, rng = fract(ro.xy, &r);\n\n\t\tfloat3 finalCol = (float3)(0.0f,0.0f,0.0f);\n        float3 fCum = (float3)(1.0f,1.0f,1.0f);\n\n\t\tMaterial obj;\n\t\tobj.emission = (float3)(0.0f,0.1f,0.0f);\n\t\tobj.colour = (float3)(.8f,1.f,0.9f);\n\t\tobj.type = CHECK;\n\t\n\t\tfloat iFrame =1.f;\n    \n\t\tfor (int depth = 0; depth < PATH_TRACING_DEPTH; depth++)\n        {\n              \/\/  float t = 0.0;                            \/\/ distance to intersection\n               \/\/ int id = 0;                               \/\/ id of intersected object\n             \/\/   Sphere obj;\n\t\t\t\tfloat3 res = trace( ro, rd, ctx);\n\t\t\t\tfloat t = res.x;\n\n\t\t\t\tif (t<=0.f) {\n                    break;\n\t\t\t\t}\n\n                float3 x = ro + rd * t;\n                float3 n = calcNormal(x, t, ctx);\n                float3 nl = dot(n,rd) < 0.0f ? n : n * -1.0f;\n                float3 f = obj.colour;\n\n                float p = max(max(f.x,f.y),f.z);\n\n\t\t\t\trng.x = rand( rng );\n\t\t\t\t\n                if ( rng.x < p)\n                    f = f \/ p;\n                else\n                    break; \/\/R.R.\n\n                fCum = f * fCum;\n\n                if (obj.type == DIFF || obj.type == CHECK) \/\/ Ideal DIFFUSE reflection\n                {\n\t\t\t\t\tif( obj.type == CHECK )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif( (fmod(x.x,80.0f) < 40.0f && fmod(x.z,80.0) < 40.0f) || \n\t\t\t\t\t\t\t\t(fmod(x.x,80.0f) > 40.0f && fmod(x.z,80.0f) > 40.0) )\n\t\t\t\t\t\t\t\tfCum *= 0.3f;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\n                    float r1 = 2.f * 3.1415926536f * rand( rng ); rng.x = sin(r1 - iFrame);\n                    float r2 = rand( rng ); rng.y = sin(r2 + iFrame);\n                    float r2s = sqrt(r2);\n                    float3 w = nl;\n\t\t\t\t\tfloat3 u = normalize(cross( (fabs(w.x) > .1f ? (float3)(0.f, 1.0, 0.f) : (float3)(1.0,1.0,1.0)) , w));\n\t\t\t\t\tfloat3 v = cross(w,u);\n                    float3 d = normalize(u * cos(r1) * r2s + v * sin(r1) * r2s + w * sqrt(1.f - r2));\n                    finalCol = finalCol + fCum * obj.emission;\n                    ro = x;\n\t\trd = d;\n                    continue;\n                }\n                else\n                    if (obj.type == SPEC)            \/\/ Ideal SPECULAR reflection\n                    {\n                        finalCol = finalCol + fCum * obj.emission;\n                        ro = x;\n\t\t   rd = rd - n * 2.f * dot(n,rd);\n                        continue;\n                    }\n\n                \/\/ Ideal dielectric REFRACTION\n                float3 reflRayRo = x;\n\t      float3 reflRayRd = rd - n * 2.f * dot(n,rd);     \n\t      bool into = dot(n,nl) > 0.f;                \/\/ Ray from outside going in?\n\n                float nc = 1.0;   \/\/ IOR of air\n                float nt = 1.5f; \/\/ IOR of solid\n                float nnt = into ? nc \/ nt : nt \/ nc;\n                float ddn = dot(rd , nl);\n                float cos2t = 1.f - nnt * nnt * (1.f - ddn * ddn);\n\n                if (cos2t < 0.f)    \/\/ Total internal reflection\n                {\n                    finalCol = finalCol + fCum * obj.emission;\n                    ro = reflRayRo;\n\t\trd = reflRayRd;\n                    continue;\n                }\n\n                float3 tdir = normalize(rd * nnt - n * ((into ? 1.0 : -1.0) * (ddn * nnt + sqrt(cos2t))));\n\n                float a = nt - nc;\n                float b = nt + nc;\n                float R0 = a * a \/ (b * b);\n                float c = 1.f - (into ? -ddn : dot(tdir,n));\n                float Re = R0 + (1.f - R0) * c * c * c * c * c;\n                float Tr = 1.f - Re;\n                float P = .25f + .5 * Re;\n                float RP = Re \/ P;\n                float TP = Tr \/ (1.f - P);\n\n\t\trng.y = rand(rng);\n\t\t\t\t\n                if( rng.y < P )\n                {\n                    ro = reflRayRo;\n                    rd = reflRayRd;\n                    fCum = fCum * RP;\n                    finalCol = finalCol + fCum * obj.emission;\n                }\n                else\n                {\n                    ro = x;\n\t\trd = tdir;\n                    fCum = fCum * TP;\n                    finalCol = finalCol + fCum * obj.emission;\n                }\n\t\t\t\t\n\t\t\t\t\/\/ we reached something bright, don't spawn any more rays\n                if (length( obj.emission ) > 100.f)\n                    break;\n\n            }\n\n            return finalCol;\n\t}\n\n__kernel void render(float3 ro, float3 ww, float3 uu, const float4 sliderMins, const float4 sliderMaxs, \n    write_only image2d_t outputImage, const float4 deltaPix, read_only image2d_t demPalette,\n    global write_only float* zBuffer, const float4 camera) {\n    \n    const int x = get_global_id(0);\n    const int y = get_global_id(1);\n    const int2 outSize = get_image_dim(outputImage);\n    \n\n\n    if (x>=outSize.x || y>=outSize.y) return;\n    \n    const float3 RotVector = sliderMins.xyz;\/\/(float3)(0.5f,-0.05f,-0.5f);\n    matrix3 matRot = rotationMatrix3(normalize(RotVector), 99.f);\n\n\tContext ctx = {sliderMins, sliderMaxs, matRot};\n    \/\/ create ray with depth of field\n    const float fov = camera.x; \/\/ 3.f;\n       \t\n   \/\/ ro.y -= 40.f;\t\n  \/\/  ta.y -= 3.f;\n\n    float2 res = convert_float2(outSize);\n    const float2 q = ((float2)(x,y)+deltaPix.xy)\/res;\n\n#ifdef WITH_DEPTH_OF_FIELD\n    float FOCUSDISTANCE = camera.y; \/\/.05f;\/\/length(ro-ta)*.75f;\n    const float3 rd = RD_DOF(&ro, ww, uu, (float)(x)+deltaPix.x, (float)(y)+deltaPix.y, outSize, fov, FOCUSDISTANCE, deltaPix.zw); \n#else\n    const float3 rd = RD(ro, ww, uu, (float)(x)+deltaPix.x, (float)(y)+deltaPix.y, outSize, fov);\n#endif\t\n\n    const float3 cback = (float3)(.1*(1.-length(q-.5)));\n    float dist = 0.f;\n    float3 col = renderScene(ro, rd, &ctx, &dist);\n\n#ifdef WITH_VIGNETING\n    col *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .3); \/\/ vigneting\n#endif\n\n    float4 out = (float4)(clamp(col,(float3)(0.f), (float3)(1.f)),1.f);\n\n#ifdef TEXTURE_OUT_FLOAT\n    write_imagef(outputImage, (int2)(x, y), out); \n#else\n    uint4 rgba = (uint4)((int)(out.z*256.f),\n                         (int)(out.y*256.f),\n                         (int)(out.x*256.f), 256);\n    write_imageui(outputImage, (int2)(x, y), rgba); \n#endif\n    zBuffer[x+y*outSize.x] = dist;\n}\n\n\n\/\/__kernel void dummy(const float3 roo) {\n\/\/    \n\/\/}\n\n\n","camera":{"aperture":0.0,"focal":3.0,"pos":["-19.563905329097864","-9.423297840376271","14.25384288969072"],"focdist":1.0,"width":442,"up":["0.014449062238133803","-0.8497989551228594","-0.5269088730250564"],"look":["0.7199954570832625","0.3745031749022026","-0.5842550074818652"],"height":458}}