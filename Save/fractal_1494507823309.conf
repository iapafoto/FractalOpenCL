{"slider":{"sliderMins":["-1.0474","-1.0423","-1.0948","0.5"],"sliderMaxs":["1.1076","1.0423","1.1972","0.9"],"sliders":["0.6594","0.9565","0.6261","10.0"]},"code":"#define TEXTURE_IN_FLOAT\n\/\/#define TEXTURE_OUT_FLOAT\n\n#define DE_RAY pseudoKleinianSlider\n#define DE_COLOR pseudoKleinianSliderColor\n\n\/\/ #define DE kleinian\n\/\/ #define DE deSpace\n\/\/ #define DE apollonian\n\n\/\/#define WITH_SHADOWS\n\/\/#define WITH_SUN\n\/\/#define WITH_AO\n\/\/#define ONLY_AO\n\/\/#define WITH_VIGNETING\n\/\/#define WITH_DEPTH_OF_FIELD\n\/\/#define WITH_ISOLINE\n\n#ifdef ONLY_AO\n    #define BACK_COLOR (float3)(.8f, .8f, .8f) \n#else \n    #define BACK_COLOR (float3)(.08f, .16f, .34f) \n\/\/    #define BACK_COLOR (float3)(.8f, .65f, .54f) \n#endif\n\n#define FOCUSBLUR .005f\n\n#define PRECISION_FACTOR 1e-4\n#define MIN_DIST_RAYMARCHING .01f\n#define MAX_DIST_RAYMARCHING 5.f\n\n#define MIN_DIST_SHADOW 10.f*PRECISION_FACTOR\n#define MAX_DIST_SHADOW 3.f\n#define PRECISION_FACTOR_SHADOW PRECISION_FACTOR\n\n#define MIN_DIST_AO 10.f*PRECISION_FACTOR\n#define MAX_DIST_AO .2f\n#define PRECISION_FACTOR_AO PRECISION_FACTOR\n\n#define LIGHT_VEC normalize((float3)(.2,.7, 1.6) )\n\n#define NB_ITERATION 7\n\n\nconst sampler_t sampler_linear = CLK_NORMALIZED_COORDS_FALSE |  CLK_ADDRESS_CLAMP_TO_EDGE | CLK_FILTER_LINEAR;\n\n__constant float3 COLOR_WATER = (float3)(0.3f, 0.13f, 0.08f);\n__constant float3 COLOR_BACK = (float3)(.42f,.46f,.48f);    \n\n__constant int iter = 100;\n__constant float eps = 0.001f, far = 3.f;\n\ntypedef struct Context {\n    const float4 mins;\n    const float4 maxs;\n} Context;\n\n\ninline float3 reflect(const float3 i, const float3 n){\n  return i - 2.f * n * dot(n,i);\n}\n\n\/\/ -------------------------------------------------------------------\n\ninline float hash1(const float seed) {\n    float fractptr;\n    return fract(sin(seed)*43758.5453123f, &fractptr);\n}\ninline float2 hash2(const float seed) {\n    float2 fractptr;\n    return fract(sin((float2)(seed*43758.5453123f,(seed+.1)*22578.1459123f)), &fractptr);\n}\ninline float3 hash3(const float seed) {\n    float3 fractptr;\n    return fract(sin((float3)(seed,seed+.1f,seed+.2f))*(float3)(43758.5453123f,22578.1459123f,19642.3490423f), &fractptr);\n}\n\ninline float3 randomCosWeightedHemiSphereVector(const float3 n, const float seed) {\n    const float r1 = 2.f*M_PI_F*hash1(seed), r2 = hash1(seed+.1f);\n    const float3 u = normalize(cross(n, (float3)(0.f,1.f,1.f))), v = cross(u,n);\n    return normalize(sqrt(r2)*(cos(r1)*u + sin(r1)*v) + sqrt(1.f-r2)*n);\n}\n\ninline float3 randomSphereDirection(const float seed) {\n    float2 r = 2.f*M_PI_F*hash2(seed);\n    return (float3)(sin(r.x)*(float2)(sin(r.y),cos(r.y)),cos(r.x));\n}\n\ninline float3 randomHemisphereDirection(const float3 n, const float seed) {\n    float2 r = 2.f*M_PI_F*hash2(seed);\n    float3 dr =  (float3)(sin(r.x)*(float2)(sin(r.y),cos(r.y)),cos(r.x));\n    float k = dot(dr,n);\n    return k == 0.f ? n : normalize(k*dr);\n}\n\n\nint box(const float3 ro, const float3 rd, const float3 sz, float* tN, float* tF, float3* n) {\n    const float3 m = 1.f\/rd,  k = fabs(m)*sz,  a = -m*ro-k*.5f, b = a+k;\n    *n = -sign(rd) * step(a.yzx,a.xyz) * step(a.zxy,a.xyz);\n    *tN = max(max(a.x,a.y),a.z);\n    *tF = min(min(b.x,b.y),b.z);\n    return *tN<*tF && *tF>0.f ? 1.f : 0.f;\n}\n\ninline float map(const float a0, const float b0, const float a1, const float b1, const float v) {\n    return mix(a1,b1,(v-a0)\/(b0-a0));\n}\n\n\/\/ -----------------------------------------------------\n\nfloat cylUnion(const float3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.f;\n}\n\nfloat cylIntersection(const float3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.f;\n}\n\n\n\n#define R(p, a) p=cos(a)*p+sin(a)*(float2)(p.y, -p.x)\n\n\/\/------------------------------------------------------------------------------\ninline float4 formula(float4 p) {\n    p.xz = fabs(p.xz+1.f)-fabs(p.xz-1.f)-p.xz;\n    p = p*2.f\/clamp(dot(p.xyz,p.xyz),.15f,1.f)-(float4)(0.5f,0.5f,0.8f,0.f);\n    R(p.xy, .5f);\n    return p;\n}\n\nfloat screen(const float3 p) {\n\tconst float d1=length(p.yz-(float2)(.25f,0.f))-.5f,\t\n                    d2=length(p.yz-(float2)(.25f,2.f))-.5f;\t\n\treturn min(max(d1,fabs(p.x-.3f)-.01f),max(d2,fabs(p.x+2.3f)-.01f));\n}\n\nfloat3 deSpace(const float3 pos, const Context* ctx) {\n\tfloat hid=0.;\n\tfloat3 tpos=pos;\n\ttpos.z = fabs(2.f-fmod(tpos.z,4.f));\n\tfloat4 p=(float4)(tpos,1.5f);\n\tfloat y=max(0.,.35f-fabs(pos.y-3.35f))\/.35f;\n#ifdef LESSDETAIL\n\tfor (int i=0; i<6; i++) {\n            p=formula(p);\n        }\n\tfloat fr=max(-tpos.x-4.f,(length(max((float2)(0.),p.yz-2.f))-.5f)\/p.w);\n#else \n\tfor (int i=0; i<8; i++) {\n            p=formula(p);\n        }\n\tfloat fr=max(-tpos.x-4.f,(length(max((float2)(0.),p.yz-3.f)))\/p.w);\n#endif\t\n\n\tfloat sc=screen(tpos);\n\tfloat d=min(sc,fr);\n\tif (fabs(d-sc)<.001f) hid=1.f;\n\treturn (float3)(d,hid,0.f);\n}\n\n\/\/------------------------------------------------------------------------------\n\n\/\/ MandelBulb\n\ninline float mandelBulb(float3 p, const Context* ctx) {\n\tp.xyz = p.xzy;\n\tfloat3 z = p;\n\tfloat3 dz = (float3)(0.f);\n\tfloat power = 8.f;\n\tfloat r, theta, phi;\n\tfloat dr = 1.f;\n\/\/\tfloat t0 = 1.f;\n\tfor(int i = 0; i < 7; ++i) {\n\t\tr = length(z);\n\t\tif (r > 2.f) break;\n\t\ttheta = atan(z.y \/ z.x);\n\t\tphi = asin(z.z \/ r);\n\t\tdr = pow(r, power - 1.f) * dr * power + 1.f;\n\t\tr = pow(r, power);\n\t\ttheta = theta * power;\n\t\tphi = phi * power;\t\t\n\t\tz = r * (float3)(cos(theta)*cos(phi), sin(theta)*cos(phi), sin(phi)) + p;\n\t\t\/\/t0 = min(t0, r);\n\t}\n\/\/\treturn (float)(0.5f * log(r) * r \/ dr, t0, 0.f);\n\treturn 0.5f * log(r) * r \/ dr;\n}\n\n\n__constant float3 va = (float3)(  0.f,  0.57735f,  0.f );\n__constant float3 vb = (float3)(  0.f, -1.f,  1.15470f );\n__constant float3 vc = (float3)(  1.f, -1.f, -0.57735f );\n__constant float3 vd = (float3)( -1.f, -1.f, -0.57735f );\n\nfloat sierpinski(float3 p, const Context* ctx) {\n    float r = 1.f, dm,d;\n    float3 v;\n    for( int i=0; i<8; i++ ) {\n\td = dot(p-va,p-va);              v=va; dm=d;\n        d = dot(p-vb,p-vb); if( d<dm ) { v=vb; dm=d; }\n\td = dot(p-vc,p-vc); if( d<dm ) { v=vc; dm=d; }\n\td = dot(p-vd,p-vd); if( d<dm ) { v=vd; dm=d; }\n\tp = v + 2.f*(p - v); \n        r *= 2.f;\n   }\n   return (sqrt(dm)-1.f)\/r;\n}\n\nfloat3 sierpinskiColor(float3 p, const Context* ctx) {\n    float a = 0.f, s = 1.f, r = 1.f, dm,d,t;\n    float3 v;\n    for( int i=0; i<8; i++ ) {\n\td = dot(p-va,p-va);              v=va; dm=d; t=0.f;\n        d = dot(p-vb,p-vb); if( d<dm ) { v=vb; dm=d; t=1.f; }\n\td = dot(p-vc,p-vc); if( d<dm ) { v=vc; dm=d; t=2.f; }\n\td = dot(p-vd,p-vd); if( d<dm ) { v=vd; dm=d; t=3.f; }\n\tp = v + 2.f*(p - v); \n        r *= 2.f;\n\ta = t + 4.f*a; s*= 4.f;\n   }\n   return (float3)( (sqrt(dm)-1.0)\/r, a\/s, t );\n}\n\n\/\/ Cylinder\ninline float fracCylinder(float3 p,const Context* ctx){\n    float r;\n    float d2,d = cylIntersection(p);\n    float s = 1.f;\n    for(int i = 0;i<5;i++){\n        p *= 3.f;\n        s*=3.f;\n        d2 = cylUnion(p) \/ s;\n        d = max(d,-d2);\n        p = sign(p)*fmod(p+1.f , 2.f) - 1.f; \t\n    }\n    return d;\n}\n\n\/\/Apollonian Fractal Distance\ninline float3 apollonian(float3 p,const Context* ctx){\n    float s = 1.63f;\n\tfloat scale = .8f;\n\tfloat orb = 1e3; \n\tfloat3 r;\n\tfor( int i=0; i<8;i++ ){\n\t\tp = 2.f*fract(p*.5f+.5f,&r)-1.f;\n\n\t\tfloat r2 = dot(p,p);\n\t\t\n                orb = min(orb, r2);\n\t\t\n\t\tfloat k = s\/r2;\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\treturn (float3)( 0.25f*fabs(p.y)\/scale , sqrt(orb), orb);\n}\n\n\/\/ Apollonian II\ninline float3 apollonian2( float3 p,const Context* ctx)\n{\n\tfloat scale = 1.f;\n    \tfloat col\t= 0.0;\n    float orb = 10000.f;\n float3 r;\n    for( int i=0; i<6; i++ )\n\t{\n\t\tp = -1.f+ 2.f*fract(0.5f*p+0.5f, &r);\n\n        p -= sign(p)*0.04f; \/\/ trick\n        \n        float r2 = dot(p,p);\n\t\tfloat k = 0.95f\/r2;\n\t\tp     *= k;\n\t\tscale *= k;\n\n        orb = min( orb, r2);\n\t}\n\n    float d1 = sqrt( min( min( dot(p.xy,p.xy), dot(p.yz,p.yz) ), dot(p.zx,p.zx) ) ) - 0.02f;\n    float d2 = fabs(p.y);\n    float dmi = d2;\n    float adr = 0.7f*floor((0.5f*p.y+0.5f)*8.f);\n    if( d1<d2 )\n    {\n        dmi = d1;\n        adr = 0.f;\n    }\n    return (float3)( 0.5f*dmi\/scale, adr, orb );\n}\n\n\/\/----------------------------------------------------------------------------------------\n\n\/\/mat2 rmx;\n\/\/int rotater=-1f;\n__constant float3 CSize2 = (float3)(0.63248f,0.78632f,0.875f);\n\nfloat sdSponge(float3 z){\n    z \/= .2;\n    \/\/folding\n    for(int n=0;n <4;n++) {\n       z = fabs(z);\n       z.xy = (z.x<z.y) ? z.yx : z.xy;\n       z.xz = (z.x<z.z) ? z.zx : z.xz;\n       z.zy = (z.y<z.z) ? z.yz : z.zy;\t \n       z = z*3.-2.;\n       z.z += (z.z<-1.) ? 2. : 0.;\n    }\n    \/\/distance to cube\n    z = fabs(z) - (float3)(1.);\n    float dis = min(max(z.x, max(z.y,z.z)),0.) + length(max(z,0.)); \n    \/\/scale cube size to iterations\n    return dis *.2f* pow(3.f, -3.f); \n}\n\nfloat pseudoKleinianSlider(float3 p, const Context* ctx) {\/\/knighty's pseudo kleinian\n    float k,r2, scale=1.f, orb = 1.f;\n    for(int i=0;i<NB_ITERATION;i++) {\n       \/\/ if(i==rotater)p.xy=p.xy*rmx;\n        p = 2.f*clamp(p, ctx->mins.xyz, ctx->maxs.xyz)-p;\n        r2 = dot(p,p);\n  \/\/float d = sdBox(p, (float3)(.1f*scale));\n        k = max(ctx->mins.w\/(dot(p,p)),1.f);\n        p *= k;\n        scale *= k;\n    }\n    float rxy=length(p.xy);\n    float d2 = max(rxy-ctx->maxs.w, fabs(rxy*p.z) \/ length(p))\/scale;\n\n   \/\/ float rxy=length(p.xy);\n\/\/\tfloat d2 = ((rxy*p.z) \/ length(p))\/scale;\n    \/\/float d0 = max(-rxy+ctx->maxs.w, \/*fabs*\/(rxy*p.z) \/ length(p))\/scale;\n\n\np \/= scale;\np *= 20.f;\n\tfloat d1 = sdSponge(p)\/20.f;\n\n   return .2f*min(d2, d1);\n   \/\/return .2f*sdBox(p, (float3)(.005f*scale))\/scale;\n  \/\/  float rxy=length(p.xy);\n  \/\/  return .25f*max(d - ctx->maxs.w, d)\/scale;\n}\n\/*\nfloat pseudoKleinianSlider(float3 p, const Context* ctx) {\/\/knighty's pseudo kleinian\n    float k,r2, scale=1.f, orb = 1.f;\n    for(int i=0;i<7;i++) {\n       \/\/ if(i==rotater)p.xy=p.xy*rmx;\n        p = 2.f*clamp(p, ctx->mins.xyz, ctx->maxs.xyz)-p;\n        r2 = dot(p,p);\n        k = max(ctx->mins.w\/dot(p,p),1.f);\n        p *= k;\n        scale *= k;\n    }\n    float rxy=length(p.xy);\n    return .5f*max(rxy-ctx->maxs.w, fabs(rxy*p.z) \/ length(p))\/scale;\n}\n*\/\n\nfloat3 pseudoKleinianSliderColor(float3 p, const Context* ctx) {\/\/knighty's pseudo kleinian\n    float k,r2, scale = 1.f, orb = 1.f;\n    for(int i=0;i<7;i++) {\n        p = 2.f*clamp(p, ctx->mins.xyz, ctx->maxs.xyz)-p;\n        r2 = dot(p,p);\n        orb = min(orb, r2);\n        k = max(ctx->mins.w\/r2,1.f);\n        p *= k;\n        scale *= k;\n    }\n    return (float3)(0.f, .25f+sqrt(orb), orb);\n}\n\n\/\/----------------------------------------------------------------------------------------\n#define CSize  (float3)(.808f, .8f, 1.137f)\n\nfloat3 kleinian(float3 p, const Context* ctx ) {\n\tfloat scale = 1.f,\n\t      r2,k, col = 0.f, \n              orb = 1.f;\n\tfloat3 p1;\n\n\tfor( int i=0; i < 9;i++ ) { \n            p1 = 2.f*clamp(p, -CSize, CSize) - p;\n            col += fabs(p.z-p1.z);\n            p = p1;\n            r2 = dot(p,p);\n            orb = min(orb, r2);\n            k = max(1.15f\/r2, 1.f);\n            p     *= k;\n            scale *= k;\n\t}\n\tconst float \n                l = length(p.xy),\n                n = l * p.z,\n                iGlobalTime = 1.f,\n                rxy = max(l - 4.f, -(n) \/ (length(p))-.07+sin(iGlobalTime*2.f+p.x+p.y+23.5f*p.z)*.02f);\n\treturn (float3)(.5f*(rxy) \/ fabs(scale), sqrt(orb), col);\n}\n\n\/*\nfloat3 pal( float t, float3 a, float3 b, float3 c, float3 d ) {\n    return a + b*cos( 6.28318f*(c*t+d) );\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat3 kleinianColour(float3 p,const Context* ctx)\n{\nfloat iGlobalTime = 1.f;\n\tfloat col\t= 0.0;\n\tfloat k, r2\t= dot(p,p);\n\tfloat add = sin(iGlobalTime)*.2f+.1f;\n\tfloat3 p1;\n\tfor( int i=0; i < 10;i++ )\n\t{\n            p1= 2.0 * clamp(p, -CSize, CSize)-p;\n            col += fabs(p.z-p1.z);\n            p = p1;\n            r2 = dot(p,p);\n            k = max((1.15)\/r2, 1.0);\n            p *= k;\n\t}\n\treturn (0.5f+0.5f*sin(col*(float3)(.6f ,-.9f ,4.9f)))*.75f + .15f;\n    \/\/return pal(0.5+0.5*sin(col), vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    \/\/return pal(0.5+0.5*cos(col), vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n}\n*\/\n\n\ninline float rayIntersect(const float3 ro, const float3 rd, const Context* ctx, const float precision, const float mind, const float maxd) {\n    float h, t = mind;\n    for(int i=0; i<192; i++ ) {\n        h = DE_RAY(ro+rd*t, ctx);\n        if (h<precision*t || t>maxd) \n            return t;\n        t += h;\n    }\n    return -1.f;\n}\n\nfloat3 trace(const float3 ro, const float3 rd, const Context* ctx ) {\n    const float d = rayIntersect(ro, rd, ctx, PRECISION_FACTOR, MIN_DIST_RAYMARCHING, MAX_DIST_RAYMARCHING);\n    if (d>0.f) {\n        return (float3)(d, DE_COLOR(ro+rd*d, ctx).yz);\n    }\n    return (float3)(-1.f, 1.f, 0.f);\n}\n\n#ifdef WITH_AO\n\nfloat calcAO(const float3 ro, const float3 n, const Context* ctx) {\n    const float seed = hash1(ro.x*(ro.y*32.56)+ro.z*147.2 + ro.y);\n    const float3 rd = randomHemisphereDirection(n, seed);    \n    const float d = rayIntersect(ro, rd, ctx, PRECISION_FACTOR_AO, MIN_DIST_AO, MAX_DIST_AO);\n    if (d>0.f) {\n        return 1.f-clamp((MAX_DIST_AO-d)\/(MAX_DIST_AO),0.f,1.f);\n    }\n    return 1.f;\n}\n\n#endif\n\n#ifdef WITH_SHADOWS\n\nfloat shadow(const float3 ro, const float3 rd,const Context* ctx ) {\n    const float \n        seed = hash1(ro.x*(ro.y*32.56)+ro.z*147.2 + ro.y),\n        d = rayIntersect(ro, rd, ctx, PRECISION_FACTOR_SHADOW, MIN_DIST_SHADOW, MAX_DIST_SHADOW);\n    if (d>0.f) {\n        return smoothstep(0.f, MAX_DIST_SHADOW, d);\n    }\n    return 1.f;\n}\n\n#endif\n\n\n\/*\nfloat3 trace(const float3 ro, const float3 rd, const Context* ctx ) {\n    const float maxd = MAX_DIST_RAYMARCHING;\n  \n    float precis, h, t = MIN_DIST_RAYMARCHING;\n    float2 info = (float2)(0.f);\n    float3 r;\n    for(int i=0; i<256; i++ ) {\n        precis = PRECISION_FACTOR*t;\n        r = DE(ro+rd*t, ctx );\n        h = r.x;\n        info = r.yz;\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if (t>maxd) t=-1.f;\n    return (float3)(t, info);\n}\n*\/\n\n#ifdef WITH_AO\n\nfloat3 forwardSF(float i, float n) {\n    float r;\n    const float PI  = 3.141592653589793238f;\n    const float PHI = 1.618033988749894848f;\n    float phi = 2.0*PI*fract(i\/PHI,&r);\n    float zi = 1.f - (2.f*i+1.f)\/n;\n    float sinTheta = sqrt( 1.f - zi*zi);\n    return (float3)( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nfloat calcAO2( float3 pos, float3 nor, const Context* ctx ) {\n    float ao = 0.f;\n    float3 w;\n    for(int i=0; i<16; i++ ) {\n        w = forwardSF( (float)i, 16.f );\n\tw *= sign( dot(w,nor) );\n        float h = ((float)i)\/15.f;\n        ao += clamp( DE_RAY(pos + nor*0.01f + w*h*0.15f, ctx)*2.f, 0.f, 1.f );\n    }\n    ao \/= 16.f;\n    return clamp( ao*16.f, 0.f, 1.f );\n}\n\n\/*\nfloat calcAO(const float3 ro, const float3 n, const Context* ctx) {\n    float t, ao = 0.f, h;\n    const float\n\tdMin = MIN_DIST_AO, \n\tdMax = MAX_DIST_AO, \n\tseed = ro.x*(ro.y*32.56)+ro.z*147.2 + ro.y;\n\n    float3 n2, rd;\n    float2 res;\n    rd = randomHemisphereDirection(n, seed);    \n    for(t = dMin; t<dMax; t += h) {\n        h = DE_RAY(ro + rd*t, ctx);\n       \/\/ hmin = min(h, hmin);\n        if (h<PRECISION_FACTOR_AO) break;\n    }\n    if (h<PRECISION_FACTOR_AO) {\n        \/\/ on a rencontrÃ© un obstacle\n        ao += clamp((dMax-t)\/(dMax-dMin),0.f,1.f);\n    }\n    return 1.f-ao;\n}\n*\/\n\nfloat calcAO3(float3 pos, float3 nor,const Context* ctx) {\n    float totao = 0.0;\n    for( int aoi=0; aoi<16; aoi++ ) {\n        float3 aopos = -1.0+2.0*hash3(pos.x*pos.y+pos.z+(float)(aoi)*213.47);\n        aopos *= sign( dot(aopos,nor) );\n        aopos = pos + nor*0.01f + aopos*0.04f;\n        float dd = clamp( DE_RAY( aopos, ctx )*8.0, 0.0, 1. );\n        totao += dd;\n    }\n    totao \/= 16.0;\n\t\n    return clamp( totao*totao*100.0, 0.0, 1.0 );\n}\n\nfloat calcAO4( const float3 pos, const float3 nor, const Context* ctx ) {\n    float3 aopos;\n    float hr, dd, \n          occ = 0.f,\n          sca = 1.f;\n    for( int i=0; i<5; i++ ) {\n        hr = 0.01f + 0.12f*(float)(i)\/4.f;\n        aopos =  nor * hr + pos;\n        dd = DE_RAY(aopos, ctx);\n        occ += -(dd-hr)*sca;\n        sca *= 0.95f;\n    }\n    return clamp( 1.f - 3.f*occ, 0.f, 1.f );    \n}\n\n#endif\n\n\n\n\n#ifdef WITH_SHADOWS\n\/*\nfloat shadow(const float3 ro, const float3 rd,const Context* ctx ) {\n    float t, h, hmin=1.f;\n    const float tmax = MAX_DIST_SHADOW;\n    float mint = MIN_DIST_SHADOW;\n    mint += 2.f*PRECISION_FACTOR_SHADOW*hash1(ro.x*ro.z+ro.y*213.47);\n\n    for(t = mint; t<tmax; t += h) {\n        h = DE_RAY(ro + rd*t, ctx);\n        hmin = min(h, hmin);\n        if (h<PRECISION_FACTOR_SHADOW) break;\n    }\n    return h<PRECISION_FACTOR_SHADOW ? smoothstep(.1f*tmax,.9f*tmax,t)\/\/(t\/tmax) : 1.f;\n}\n\nfloat softShadow( float3 ro, float3 rd, float mint, float tmax ) {\n\n    float res = 1.f;\n    float h, t = mint;\n    for( int i=0; i<32; i++ ) {\n        h = DE( ro + rd*t ).x;\n        res = min( res, 8.f*h\/t );\n        t += clamp( h, 0.001f, 0.1f );\n        if( h<0.001f || t>tmax ) break;\n    }\n    return clamp( res, 0.f, 1.f );\n}\n*\/\n#endif\n\n\nfloat3 getRay(float3 ro, float3 look, float2 uv){\n    float3 f = normalize(look - ro);\n    float3 r = normalize((float3)(f.z,0.f,-f.x));\n    float3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nfloat3 calcNormal( float3 pos, float t,const Context* ctx ){\n    const float precis = PRECISION_FACTOR * t * 0.57f;\n    const float3 e = (float3)(precis, -precis, 0.f);\n\n    return normalize(e.xyy*DE_RAY(pos + e.xyy, ctx) + \n\t\t     e.yyx*DE_RAY(pos + e.yyx, ctx) + \n\t\t     e.yxy*DE_RAY(pos + e.yxy, ctx) + \n                     e.xxx*DE_RAY(pos + e.xxx, ctx) );\n}\n\n\/*\nfloat3 calcNormal(const float3 p, const float t, const Context* ctx){\n    const float eps = PRECISION_FACTOR * t * 0.57f;\n    float3 e = (float3)(eps, 0.f, 0.f);\n    return normalize((float3)(\n\t\tDE_RAY(p+e.xyy,ctx)-DE_RAY(p-e.xyy,ctx),\n\t\tDE_RAY(p+e.yxy,ctx)-DE_RAY(p-e.yxy,ctx),\n\t\tDE_RAY(p+e.yyx,ctx)-DE_RAY(p-e.yyx,ctx)));\n}\n*\/\n\n\/*\nfloat3 light(float3 p, float3 n){\n\n    float3 col = (float3)(0);\n    float3 l1 = normalize((float3)(1,2,1));\n    float3 l2 = normalize((float3)(-1,1,-2));\n\n    float diff = max(dot(n,l1),0.);\n    diff *= getShadow(p, n, l1);\n    col += diff * (float3)(1,.8,.5);\n    diff = max(dot(n,l2),0.);\n    diff *= getShadow(p, n, l2);\n    col += diff * (float3)(.6,.8,1);\n\n    return col * .5;\n}\n*\/\n\n\n\/\/ Cameras \n#ifndef WITH_DEPTH_OF_FIELD\n\nfloat3 RD(const float3 ro, const float3 ww,  const float3 uu, const float x, const float y, const int2 res, const float fov) {\n    const float3 \n\/\/        ww = normalize(ta - ro),\n\/\/        uu = normalize(cross(ww, (float3)(0.f,0.f,1.f))), \/\/ up\n        vv = normalize(cross(uu,ww));\n\n    const float2 resF = convert_float2(res);\n    const float px = (2.f * (x\/resF.x) - 1.f) * resF.x\/resF.y, \n                py = (2.f * (y\/resF.y) - 1.f);  \n\n    float3 er = normalize( (float3)( px, py, fov) );\n    return normalize( er.x*uu + er.y*vv + er.z*ww );\n    \/\/return normalize( px*uu + py*vv + fov*ww );\n}\n\n#else\n\n\nfloat3 RD_DOF(float3* ro, const float3 ww, const float3 uu, const float x, const float y, const int2 res, const float fov, const float focusDist, const float2 rv2) {\n    const float3\n   \/\/     ww = normalize(ta - *ro),\n   \/\/     uu = normalize(cross(ww, (float3)(0.f,0.f,1.f))), \/\/ up\n        vv = normalize(cross(uu,ww));\n   \n \/\/float2 rv2 = hash2(24.4316544311f*seed);  \n    float2 resF = convert_float2(res);\n    float2 q = ((float2)(x,y))\/resF;\n\n    float2 p = 2.f*q - 1.f;\n    p.x *= resF.x\/resF.y;\n\n    float2 pt = p + rv2\/resF;   \n \n\n    float3 er = normalize( (float3)( pt.xy, fov*2.f ) );\n    float3 rd = er.x*uu + er.y*vv + er.z*ww;\n\n    float3 go = FOCUSBLUR*(float3)(2.f*rv2-1.f, 0.f);\n    float3 gd = normalize( er*focusDist - go );\n\n    *ro += go.x*uu + go.y*vv;\n    rd += gd.x*uu + gd.y*vv;\n    rd = normalize(rd);\n    return rd;\n}\n\n#endif\n\nfloat3 renderScene(float3 ro, float3 rd, const Context* ctx, float* dist) {\n    float3 col = (float3)(0.f);\n    float3 res = trace( ro, rd, ctx);\n    float t = res.x;\n    *dist = t;\n    if (t>0.f) {\n        float3 pos = ro + t*rd;\n        float3 nor = calcNormal( pos, t, ctx);\n        float3 ref = reflect( rd, nor);\n \/\/ Color\n\tcol = 0.5f + 0.5f*cos( 6.2831f*res.y + (float3)(0.f,1.f,2.f) ); \n\n \/\/ lighting        \n        float3 lig = LIGHT_VEC; \n        float3 hal = normalize( lig-rd);\n\n#ifdef WITH_AO\n        float occ = calcAO( pos, nor, ctx);\n#else\n        float occ = 1.f;\n#endif\n\n#ifdef WITH_SHADOWS\n       float sh = .5f+.5f*shadow( pos, lig, ctx );\n#else\n        float sh = 1.f;\n#endif\n\n#ifdef ONLY_AO\n\tcol = (float3)occ*(.5f+.5f*sh);\n#else\n\n        float amb = .3;\/\/clamp(0.5+0.5*nor.y, 0.f, 1.f );\n\n        float dif = clamp( dot( nor, lig ), 0.f, 1.f );\n        float bac = clamp( dot( nor, normalize((float3)(-lig.x,0.f,-lig.z))), 0.f, 1.f )*clamp( 1.f-pos.y,0.f,1.f);\n        float dom = smoothstep( -0.1f, 0.1f, ref.y );\n        float fre = clamp(1.0+dot(nor,rd),0.f,1.f);\n        fre *= fre;\n        float spe = pow(clamp( dot( ref, lig ), 0.f, 1.f ),16.f);\n\n       \/\/ dom *= softshadow( pos, ref, 0.02f, 2.5f );\n\n\tfloat3 lin = (float3)(.5f) + \n            + 1.3f*sh*dif*(float3)(1.f,0.8f,0.55f)\n            + 2.f*spe*(float3)(1.f,0.9f,0.7f)*dif\n            + .5f*occ*( .4f*amb*(float3)(0.4f,0.6f,1.f) +\n                    .5f*sh*(float3)(0.4f,0.6f,1.f) +\n                   \/\/ .5f*bac*(float3)(0.25f,0.25f,0.25f) +\n                    .25f*fre*(float3)(1.f,1.f,1.f));\n\n\tcol = col*lin;\n\n   \/\/ \tcol = mix( col, (float3)(0.8f,0.9f,1.f), 1.f-exp( -0.0002f*t*t*t ) );\n        \/\/ Light attenuation, based on the distances above.\n\n#endif\n\t    \/\/ Shading.\n       float lDist = t;\n       float atten = 1.f\/(1.f + lDist*.2f + lDist*0.1f); \/\/ + distlpsp*distlpsp*0.02\n       col *= atten*col*occ;\n       col = mix(col, BACK_COLOR, smoothstep(0.f, .95f, t\/MAX_DIST_RAYMARCHING)); \/\/ exp(-.002*t*t), etc.\n\n    } else {\n\tcol = BACK_COLOR;\/\/ (float3)(.08f, .16f, .34f);  \t\n    }\n\n    return sqrt(col);\n}\n\n__kernel void render(float3 ro, float3 ww, float3 uu, const float4 sliderMins, const float4 sliderMaxs, \n    write_only image2d_t outputImage, const float4 deltaPix, read_only image2d_t demPalette,\n    global write_only float* zBuffer, const float4 camera) {\n    \n    const int x = get_global_id(0);\n    const int y = get_global_id(1);\n    const int2 outSize = get_image_dim(outputImage);\n    \n    if (x>=outSize.x || y>=outSize.y) return;\n\tContext ctx = {sliderMins, sliderMaxs};\n    \/\/ create ray with depth of field\n    const float fov = .7f*camera.x; \/\/ 3.f;\n       \t\n  \/\/  ro.y -= 3.f;\t\n  \/\/  ta.y -= 3.f;\n\n    float2 res = convert_float2(outSize);\n    const float2 q = ((float2)(x,y)+deltaPix.xy)\/res;\n\n#ifdef WITH_DEPTH_OF_FIELD\n    float FOCUSDISTANCE = camera.y; \/\/.05f;\/\/length(ro-ta)*.75f;\n    const float3 rd = RD_DOF(&ro, ww, uu, (float)(x)+deltaPix.x, (float)(y)+deltaPix.y, outSize, fov, FOCUSDISTANCE, deltaPix.zw); \n#else\n    const float3 rd = RD(ro, ww, uu, (float)(x)+deltaPix.x, (float)(y)+deltaPix.y, outSize, fov);\n#endif\t\n\n    const float3 cback = (float3)(.1*(1.-length(q-.5)));\n    float dist = 0.f;\n    float3 col = renderScene(ro, rd, &ctx, &dist);\n\n#ifdef WITH_VIGNETING\n    col *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .3); \/\/ vigneting\n#endif\n\n    float4 out = (float4)(clamp(col,(float3)(0.f), (float3)(1.f)),1.f);\n\n#ifdef TEXTURE_OUT_FLOAT\n    write_imagef(outputImage, (int2)(x, y), out); \n#else\n    uint4 rgba = (uint4)((int)(out.z*256.f),\n                         (int)(out.y*256.f),\n                         (int)(out.x*256.f), 256);\n    write_imageui(outputImage, (int2)(x, y), rgba); \n#endif\n    zBuffer[x+y*outSize.x] = dist;\n}\n\n\n\/\/__kernel void dummy(const float3 roo) {\n\/\/    \n\/\/}\n\n\n","camera":{"aperture":0.0,"focal":3.0,"pos":["0.3483770422266935","0.2605244455278373","0.42356817307400463"],"focdist":1.050137996673584,"width":470,"up":["-0.43970792554927773","-0.22106771288824228","0.8705090502272292"],"look":["-0.6735655692485712","-0.559970138521667","-0.4824343145826934"],"height":298}}